// Copyright 2021 The Parca Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metastore

import (
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
)

func TestMappingKeyBytes(t *testing.T) {
	k := MappingKey{
		Size:          1,
		Offset:        2,
		BuildIDOrFile: "",
	}

	require.Equal(t, k.Bytes(), []byte{
		0x6d,
		0x61,
		0x70,
		0x70,
		0x69,
		0x6e,
		0x67,
		0x73,
		0x2f,
		0x62,
		0x79,
		0x2d,
		0x6b,
		0x65,
		0x79,
		0x2f,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x1,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x2,
	})

	k = MappingKey{
		Size:          1,
		Offset:        2,
		BuildIDOrFile: "a",
	}

	require.Equal(t, k.Bytes(), []byte{
		0x6d,
		0x61,
		0x70,
		0x70,
		0x69,
		0x6e,
		0x67,
		0x73,
		0x2f,
		0x62,
		0x79,
		0x2d,
		0x6b,
		0x65,
		0x79,
		0x2f,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x1,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x2,
		0x61,
	})
}

func TestFunctionKeyBytes(t *testing.T) {
	k := FunctionKey{
		StartLine:  3,
		Name:       "a",
		SystemName: "b",
		Filename:   "c",
	}

	require.Equal(t, k.Bytes(), []byte{
		0x66,
		0x75,
		0x6e,
		0x63,
		0x74,
		0x69,
		0x6f,
		0x6e,
		0x73,
		0x2f,
		0x62,
		0x79,
		0x2d,
		0x6b,
		0x65,
		0x79,
		0x2f,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x0,
		0x3,
		0x61,
		0x62,
		0x63,
	})
}

func TestLocationKeyBytes(t *testing.T) {
	k := LocationKey{
		NormalizedAddress: 3,
		MappingID: uuid.UUID{
			0x02,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x03,
		},
	}

	require.Equal(t, k.Bytes(), []byte{
		0x6c,
		0x6f,
		0x63,
		0x61,
		0x74,
		0x69,
		0x6f,
		0x6e,
		0x73,
		0x2f,
		0x62,
		0x79,
		0x2d,
		0x6b,
		0x65,
		0x79,
		0x2f,
		0x02,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x03,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x03,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	})
}
